from Tkinter import *
from ttk import Notebook, Scrollbar
import tkFileDialog, os, sys, itertools, webbrowser, pickle, copy, odfpy, xlrd
from pyCellAnalyst import Volume

class StdoutRedirector(object):
    def __init__(self,text_widget):
        self.text_space = text_widget

    def write(self,string):
        self.text_space.insert('end', string)
        self.text_space.see('end')
        
class Application(Frame):
    """ This is a GUI for the pyCellAnalyst Segmentation Feature """
    def __init__(self,master):
        Frame.__init__(self,master)
        self.lastdir = os.getcwd()
        self.notebook = Notebook(self)
        self.tab1 = Frame(self.notebook)
        self.tab2 = Frame(self.notebook)
        self.tab3 = Frame(self.notebook)

        self.notebook.add(self.tab1,text="I/O")
        self.notebook.add(self.tab2,text="Filtering")
        self.notebook.add(self.tab3,text="Segmentation")
        self.notebook.grid(row=0,column=0,sticky=NW)
        
        self.directories = []
        self.ROI = []

        #default settings
        self.settings = {'xdim':                 DoubleVar(value=0.41),
                         'ydim':                 DoubleVar(value=0.41),
                         'zdim':                 DoubleVar(value=0.3),
                         'upsampling':           DoubleVar(value=2.0),
                         'thresholdPercentage':  DoubleVar(value=0.4),
                         'medianRadius':         DoubleVar(value=1),
                         'gaussianSigma':        DoubleVar(value=0.5),
                         'curvatureIterations':  IntVar(value=10),
                         'curvatureConductance': DoubleVar(value=9.0),
                         'gradientIterations':   IntVar(value=10),
                         'gradientConductance':  DoubleVar(value=9.0),
                         'gradientTimeStep':     DoubleVar(value=0.01),
                         'bilateralDomainSigma': DoubleVar(value=1.5),
                         'bilateralRangeSigma':  DoubleVar(value=10.0),
                         'bilateralSamples':     IntVar(value=100),
                         'patchRadius':          DoubleVar(value=4),
                         'patchNumber':          IntVar(value=20),
                         'patchNoiseModel':      IntVar(value=2),
                         'patchIterations':      IntVar(value=10),
                         'geodesicPropagation':  DoubleVar(value=0.1),
                         'geodesicCurvature':    DoubleVar(value=0.2),
                         'geodesicAdvection':    DoubleVar(value=1.0),
                         'geodesicIterations':   IntVar(value=1000),
                         'geodesicRMS':          DoubleVar(value=0.01),
                         'edgeLambda1':          DoubleVar(value=1.0),
                         'edgeLambda2':          DoubleVar(value=1.0),
                         'edgeIterations':       IntVar(value=20)}
        
        self.intSettings = {'stain':              IntVar(value=0),
                            'display':            IntVar(value=1),
                            'edgeEnhancement':    IntVar(value=0),
                            'contrastStretching': IntVar(value=0),
                            'fillHoles':          IntVar(value=0),
                            'handleOverlap':      IntVar(value=1),
                            'debug':              IntVar(value=0),
                            'smoothingMethod':    IntVar(value=4),
                            'thresholdMethod':    IntVar(value=3),
                            'thresholdAdaptive':  IntVar(value=1),
                            'activeMethod':       IntVar(value=2)}

        self.smoothingMethods = ['None',
                                 'Median',
                                 'Gaussian',
                                 'Curvature Diffusion',
                                 'Gradient Diffusion',
                                 'Bilateral',
                                 'Patch-based']
        
        self.thresholdMethods = ['Percentage',
                                 'Otsu',
                                 'MaxEntropy',
                                 'Li',
                                 'Huang',
                                 'IsoData',
                                 'KittlerIllingworth',
                                 'Moments',
                                 'Yen',
                                 'RenyiEntropy',
                                 'Shanbhag']
        
        for i in self.settings.keys():
            self.settings[i].trace("w",self.update)              
        self.grid()
        self.create_widgets()
        
    def create_widgets(self):
        #save/load settings
        self.buttonSaveSettings = Button(self.tab1,text="Save Settings",command=self.saveSettings)
        self.buttonSaveSettings.grid(row=1,column=0,padx=5,pady=5,sticky=W+E)
        self.buttonLoadSettings = Button(self.tab1,text="Load Settings",command=self.loadSettings)
        self.buttonLoadSettings.grid(row=1,column=1,padx=5,pady=5,sticky=W+E)
        self.buttonLoadROI = Button(self.tab1,text="Load Region of Interest File",command=self.loadROI)
        self.buttonLoadROI.grid(row=1,column=2,padx=5,pady=5,sticky=W+E)
                
        #create label frame for image directory selection
        self.directoryFrame = LabelFrame(self.tab1,text="Image directories to process")
        self.directoryFrame.grid(row=2,column=0,rowspan=2,columnspan=5,padx=5,pady=5,sticky=NW)
        #add directory
        self.buttonAddDirectory = Button(self.directoryFrame,bg='green')
        self.buttonAddDirectory["text"] = "Add"
        self.buttonAddDirectory["command"] = self.add_directory
        self.buttonAddDirectory.grid(row=2,column=0,padx=5,sticky=W+E)
        
        #remove directory
        self.buttonRemoveDirectory = Button(self.directoryFrame,bg='red')
        self.buttonRemoveDirectory["text"] = "Remove"
        self.buttonRemoveDirectory["command"] = self.remove_directory
        self.buttonRemoveDirectory.grid(row=3,column=0,padx=5,sticky=W+E)

        #directory list
        self.listDirectories = Listbox(self.directoryFrame)
        self.listDirectories["width"] = 80
        self.listDirectories["selectmode"] = MULTIPLE
        self.listDirectories.grid(row=2,column=1,rowspan=2,columnspan=4,padx=5,pady=5,sticky=E+W)

        # Image Settings
        self.imageSettingsFrame = LabelFrame(self.tab1,text="Image Settings")
        self.imageSettingsFrame.grid(row=4,column=0,columnspan=5,rowspan=2,padx=5,pady=5,sticky=E+W)
        settings = [('x-spacing','xdim'),
                    ('y-spacing','ydim'),
                    ('z-spacing','zdim'),
                    ('Upsampling Factor','upsampling')]
        for i,v in enumerate(settings):
            Label(self.imageSettingsFrame,text=v[0]).grid(row=4,column=i,padx=5,pady=5,sticky=E+W)
            Entry(self.imageSettingsFrame,textvariable=self.settings[v[1]],width=5).grid(row=5,column=i,padx=5,pady=5,sticky=E+W)
        Checkbutton(self.imageSettingsFrame,text='Objects are Dark',variable=self.intSettings['stain']).grid(row=5,column=i+1,padx=5,pady=5,sticky=NW)

        # Other settings
        ####################################################################
        self.otherSettingsFrame = LabelFrame(self.tab1,text="Other Options")
        self.otherSettingsFrame.grid(row=6,column=0,columnspan=5,padx=5,pady=5,sticky=E+W)
        settings = [('Display Objects','display'),
                    ('Edge Enhancement','edgeEnhancement'),
                    ('2D Contrast Stretching','contrastStretching'),
                    ('Fill Holes','fillHoles'),
                    ('Handle Overlap','handleOverlap'),
                    ('Debug Mode','debug')]
        for i,v in enumerate(settings):
            Checkbutton(self.otherSettingsFrame,text=v[0],variable=self.intSettings[v[1]]).grid(row=6,column=i,padx=5,pady=5,sticky=NW)
        ######################################################################
        
        #button to execute segmentation(s)
        self.buttonExecute = Button(self.tab1,bg='green',font=('Helvetica','20','bold'))
        self.buttonExecute["text"] = "Execute"
        self.buttonExecute["command"] = self.run_segmentation
        self.buttonExecute.grid(row=7,column=0,columnspan=5,padx=5,pady=5,sticky=W+E)
        
        #print STDOUT to a textbox
        self.text_box = Text(self.tab1,height=10)
        self.text_box.grid(row=8,column=0,columnspan=5,padx=5,pady=5,sticky=W+E)
        sys.stdout = StdoutRedirector(self.text_box)

        #smoothing/denoising
        methods = [("None",1),
                   ("Median",2),
                   ("Gaussian",3),
                   ("Curvature-based\nAnisotropic Diffusion",4),
                   ("Gradient-based\nAnisotropic Diffusion",5),
                   ("Bilateral",6),
                   ("Patch-based Denoising",7)]
        self.smoothingFrame = LabelFrame(self.tab2,text="Smoothing/Denoising")
        self.smoothingFrame.grid(row=0,column=0,padx=5,pady=5,sticky=NW)

        for m,i in methods:
            Radiobutton(self.smoothingFrame,
                        text=m,
                        indicatoron=0,
                        padx=5,
                        width=20,
                        variable=self.intSettings['smoothingMethod'],
                        command=self.populateSmoothingSettings,
                        value=i).pack(anchor=W)

        self.smoothingHelpFrame = LabelFrame(self.tab2,text="Description")
        self.smoothingHelpFrame.grid(row=0,column=1,padx=5,pady=5,sticky=NW)
        self.textSmoothingHelp = Text(self.smoothingHelpFrame,wrap=WORD,height=11,width=40)
        self.textSmoothingHelp.insert(END,"Apply an iterative curvature-based anisotropic diffusion filter. Higher conductance will result in more change per iteration. More iterations will result in a smoother image. This filter should preserve edges. It is better at retaining fine features than gradient-based anisotropic diffusion, and also better when the edge contrast is low.")
        self.textSmoothingHelp.pack(anchor=NW)
        self.textSmoothingHelp["state"] = DISABLED
        self.smoothingLink = r"http://www.itk.org/ItkSoftwareGuide.pdf"
        self.smoothingReference = Label(self.smoothingHelpFrame,text="Reference",fg="blue",cursor="hand2")
        self.smoothingReference.bind("<Button-1>",self.open_smoothing_reference)
        self.smoothingReference.pack(anchor=NW)
        
        self.smoothingSettingsFrame = LabelFrame(self.tab2,text="Smoothing/Denoising Settings")
        self.smoothingSettingsFrame.grid(row=0,column=2,padx=5,pady=5,sticky=NW)
        Label(self.smoothingSettingsFrame,text="No additional settings needed.").pack(anchor=W)
        
        #Threshold segmentation
        self.thresholdFrame = LabelFrame(self.tab3,text="Threshold segmentation")
        self.thresholdFrame.grid(row=0,column=0,padx=5,pady=5,sticky=NW)

        methods = [("Percentage",1),
                   ("Otsu",2),
                   ("Maximum Entropy",3),
                   ("Li",4),
                   ("Huang",5),
                   ("IsoData (Ridler-Calvard)",6),
                   ("KittlerIllingworth",7),
                   ("Moments",8),
                   ("Yen",9),
                   ("RenyiEntropy",10),
                   ("Shanbhag",11)]

        for m,i in methods:
            Radiobutton(self.thresholdFrame,
                        text=m,
                        indicatoron=0,
                        padx=5,
                        width=20,
                        variable=self.intSettings['thresholdMethod'],
                        command=self.populateThresholdSettings,
                        value=i).pack(anchor=W)
            
        self.thresholdHelpFrame = LabelFrame(self.tab3,text="Description")
        self.thresholdHelpFrame.grid(row=0,column=1,padx=5,pady=5,sticky=NW)
        self.textThresholdHelp = Text(self.thresholdHelpFrame,wrap=WORD,height=11,width=40)
        self.textThresholdHelp.insert(END,"Calculates the threshold such that entropy is maximized between the foreground and background. This has shown good performance even when objects are in close proximity.")
        self.textThresholdHelp.pack(anchor=NW)
        self.textThresholdHelp["state"] = DISABLED
        self.thresholdLink = r"http://www.itk.org/ItkSoftwareGuide.pdf"
        self.thresholdReference = Label(self.thresholdHelpFrame,text="Reference",fg="blue",cursor="hand2")
        self.thresholdReference.bind("<Button-1>",self.open_threshold_reference)
        self.thresholdReference.pack(anchor=NW)
        
        self.thresholdSettingsFrame = LabelFrame(self.tab3,text="Threshold Settings")
        self.thresholdSettingsFrame.grid(row=0,column=2,padx=5,pady=5,sticky=NW)
        Checkbutton(self.thresholdSettingsFrame,text="Iterative Threshold Adjustment",variable=self.intSettings['thresholdAdaptive']).pack(anchor=W)
        Label(self.thresholdSettingsFrame,text="     No additional settings needed.",fg='red').pack(anchor=W)


        #make Active Contour segmentation frame
        self.activeContourFrame = LabelFrame(self.tab3,text="Active contour segmentation")
        self.activeContourFrame.grid(row=1,column=0,padx=5,pady=5,sticky=NW)

        methods = [("None",1),
                   ("Geodesic Levelset",2),
                   ("Edge-free",3)]
            
        for m,i in methods:
            Radiobutton(self.activeContourFrame,
                        text=m,
                        indicatoron=0,
                        padx=5,
                        width=20,
                        variable=self.intSettings['activeMethod'],
                        command=self.populateActiveContourSettings,
                        value=i).pack(anchor=W)
            
        self.activeSettingsFrame = LabelFrame(self.tab3,text="Active Contour Settings")
        self.activeSettingsFrame.grid(row=1,column=2,padx=5,pady=5,sticky=NW)
        settings = [('Propagation','geodesicPropagation'),
                    ('Curvature','geodesicCurvature'),
                    ('Advection','geodesicAdvection'),
                    ('Iterations','geodesicIterations'),
                    ('Maximum RMS Error Change','geodesicRMS')]
        for t,v in settings:
            Label(self.activeSettingsFrame,text=t).pack(anchor=W)
            Entry(self.activeSettingsFrame,textvariable=self.settings[v]).pack(anchor=W)

        
    def populateSmoothingSettings(self):
        for child in self.smoothingSettingsFrame.pack_slaves():
            child.destroy()
        if self.intSettings['smoothingMethod'].get() == 1:
            self.smoothingReference.unbind("<Button-1>")
            self.smoothingReference["text"] = ""
        else:
            self.smoothingReference.bind("<Button-1>",self.open_smoothing_reference)
            self.smoothingReference["text"] = "Reference"
            
        if self.intSettings['smoothingMethod'].get() == 1:
            Label(self.smoothingSettingsFrame,text="No additional settings needed.").pack(anchor=W)
            self.textSmoothingHelp["state"] = NORMAL
            self.textSmoothingHelp.delete("0.0",END)
            self.textSmoothingHelp.insert(END,"No smoothing or denoising will be applied to the image.")
            self.textSmoothingHelp["state"] = DISABLED
                        
        elif self.intSettings['smoothingMethod'].get() == 2:
            settings = [('Kernel Radius','medianRadius')]
            self.textSmoothingHelp["state"] = NORMAL
            self.textSmoothingHelp.delete("0.0",END)
            self.textSmoothingHelp.insert(END,"Apply a median filter with the window size defined by Kernel Radius. A larger radius will result in a smoother image, but may degrade the edges.")
            self.textSmoothingHelp["state"] = DISABLED
                        
        elif self.intSettings['smoothingMethod'].get() == 3:
            settings = [('Gaussian Variance','gaussianSigma')]
            self.textSmoothingHelp["state"] = NORMAL
            self.textSmoothingHelp.delete("0.0",END)
            self.textSmoothingHelp.insert(END,"Apply a discrete Gaussian filter. Increasing Gaussian Variance will result in a smoother image, but will further blur edges.")
            self.textSmoothingHelp["state"] = DISABLED
                        
        elif self.intSettings['smoothingMethod'].get() == 4:
            settings = [('Conductance','curvatureConductance'),
                        ('Iterations','curvatureIterations')]
            self.textSmoothingHelp["state"] = NORMAL
            self.textSmoothingHelp.delete("0.0",END)
            self.textSmoothingHelp.insert(END,"Apply an iterative curvature-based anisotropic diffusion filter. Higher conductance will result in more change per iteration. More iterations will result in a smoother image. This filter should preserve edges. It is better at retaining fine features than gradient-based anisotropic diffusion, and also better when the edge contrast is low.")
            self.textSmoothingHelp["state"] = DISABLED
            self.smoothingLink = r"http://www.itk.org/ItkSoftwareGuide.pdf"
                                        
        elif self.intSettings['smoothingMethod'].get() == 5:
            settings = [('Conductance','gradientConductance'),
                        ('Iterations','gradientIterations'),
                        ('Time Step','gradientTimeStep')]
            self.textSmoothingHelp["state"] = NORMAL
            self.textSmoothingHelp.delete("0.0",END)
            self.textSmoothingHelp.insert(END,"Apply an iterative gradient-based anisotropic diffusion filter. Higher conductance will result in more change per iteration. More iterations will result in a smoother image. This filter should preserve edges. This may perform better than curvature-based if edge contrast is good.")           
            self.textSmoothingHelp["state"] = DISABLED
            self.smoothingLink = r"http://dx.doi.org/10.1109/34.56205"
                        
        elif self.intSettings['smoothingMethod'].get() == 6:
            settings = [('Domain Variance (increasing is costly)','bilateralDomainSigma'),
                        ('Range Variance','bilateralRangeSigma'),
                        ('Samples','bilateralSamples')]
            self.textSmoothingHelp["state"] = NORMAL
            self.textSmoothingHelp.delete("0.0",END)
            self.textSmoothingHelp.insert(END,"A bilateral filter is applied both on a neighborhood defined by the Euclidean distance (the domain) from a given voxel and a 'neighborhood' based on voxel intensities (the range). Two Gaussian kernels are defined by Domain Variance and Range Variance and the actual weight of influence a particular neighbor voxel has on the current voxel is a combination of both. A voxel that is both close in distance and similar in intensity will have a high weight. This results in edge-preserving smoothing.")
            self.textSmoothingHelp["state"] = DISABLED
            self.smoothingLink = r"http://dx.doi.org/10.1109/ICCV.1998.710815"
                        
        elif self.intSettings['smoothingMethod'].get() == 7:
            Label(self.smoothingSettingsFrame,text='Warning: CPU cost grows rapidly with increasing values.',fg='red').pack(anchor=W)
            settings = [('Patch Radius','patchRadius'),
                        ('Number of Patches','patchNumber'),
                        ('Iterations','patchIterations')]
            self.textSmoothingHelp["state"] = NORMAL
            self.textSmoothingHelp.delete("0.0",END)
            self.textSmoothingHelp.insert(END,"This filter will denoise the image using an unsupervised information-theoretic adaptive filter (SEE REFERENCE). The algorithm attempts to extract the noise based on random sampling of the image with windows of size, Patch Radius, and number, Number of Patches. No a priori knowledge of the noise is needed, but a Noise Model can be specified. Since laser fluorescence microscopy is known to have Poisson noise, this is the default. The drawback of this method is it becomes extremely costly with increasing any of its parameters.")
            self.textSmoothingHelp["state"] = DISABLED
            self.smoothingLink = r"http:/dx.doi.org/10.1109/TPAMI.2006.64"
            
        if not(self.intSettings['smoothingMethod'].get() == 1) and not(self.intSettings['smoothingMethod'].get() == 7):
            for t,v in settings:
                Label(self.smoothingSettingsFrame,text=t).pack(anchor=W)
                Entry(self.smoothingSettingsFrame,textvariable=self.settings[v]).pack(anchor=W)

        if self.intSettings['smoothingMethod'].get() == 7:
            for t,v in settings:
                Label(self.smoothingSettingsFrame,text=t).pack(anchor=W)
                Entry(self.smoothingSettingsFrame,textvariable=self.settings[v]).pack(anchor=W)
            models = [("No Model",1),
                       ("Poisson",2),
                       ("Gaussian",3),
                       ("Rician",4)]
            Label(self.smoothingSettingsFrame,text="Noise Model").pack(anchor=NW)
            for t,v in models:
                Radiobutton(self.smoothingSettingsFrame,
                            text=t,
                            indicatoron=0,
                            padx=5,
                            width=8,
                            variable=self.settings['patchNoiseModel'],
                            value=v).pack(side=LEFT)
            
    def populateThresholdSettings(self):
        for child in self.thresholdSettingsFrame.pack_slaves():
            child.destroy()
        Checkbutton(self.thresholdSettingsFrame,text="Iterative Threshold Adjustment",variable=self.intSettings['thresholdAdaptive']).pack(anchor=W)
        if self.intSettings['thresholdMethod'].get() == 1:
            Label(self.thresholdSettingsFrame,text="Ratio").pack(anchor=W)
            e = Entry(self.thresholdSettingsFrame,textvariable=self.settings['thresholdPercentage'])
            e.pack(anchor=W)
        else:
            Label(self.thresholdSettingsFrame,text="     No additional settings needed.",fg='red').pack(anchor=W)

    def populateActiveContourSettings(self):
        for child in self.activeSettingsFrame.pack_slaves():
            child.destroy()
        if self.intSettings['activeMethod'].get() == 1:
            Label(self.activeSettingsFrame,text="No additional settings needed.").pack(anchor=W)
        elif self.intSettings['activeMethod'].get() == 2:
            settings = [('Propagation','geodesicPropagation'),
                        ('Curvature','geodesicCurvature'),
                        ('Advection','geodesicAdvection'),
                        ('Iterations','geodesicIterations'),
                        ('Maximum RMS Error Change','geodesicRMS')]
            for t,v in settings:
                Label(self.activeSettingsFrame,text=t).pack(anchor=W)
                Entry(self.activeSettingsFrame,textvariable=self.settings[v]).pack(anchor=W)
        else:
            settings = [('Lambda1 (internal weight)','edgeLambda1'),
                        ('Lambda2 (external weight)','edgeLambda2'),
                        ('Iterations','edgeIterations')]
            for t,v in settings:
                Label(self.activeSettingsFrame,text=t).pack(anchor=W)
                Entry(self.activeSettingsFrame,textvariable=self.settings[v]).pack(anchor=W)

    def add_directory(self):
        dir_name = tkFileDialog.askdirectory(parent=root,initialdir=self.lastdir,title = "Select directory containing images.")
        self.lastdir = dir_name
        self.directories.append(dir_name)
        self.listDirectories.insert(END,dir_name)
        
    def remove_directory(self):
        index = self.listDirectories.curselection()
        if index:
            for i in index[::-1]:
                self.listDirectories.delete(i)
                del self.directories[i]

    def saveSettings(self):
        filename = tkFileDialog.asksaveasfilename(defaultextension=".pkl")
        if filename:
            fid = open(filename,'wb')
            tmp_settings = copy.copy(self.settings)
            for key in self.settings.keys():
                tmp_settings[key] = self.settings[key].get()
            tmp_int_settings = copy.copy(self.intSettings)
            for key in self.intSettings.keys():
                tmp_int_settings[key] = self.intSettings[key].get()
                                
            values = {"Settings":tmp_settings,
                      "ButtonStates":tmp_int_settings}
            pickle.dump(values,fid)
            fid.close()

    def loadSettings(self):
        filename = tkFileDialog.askopenfilename(parent=root,initialdir=os.getcwd(),title = "Select a saved settings file.")
        if filename:
            fid = open(filename,'rb')
            values = pickle.load(fid)
            fid.close()
            for key in self.settings:
                self.settings[key].set(values['Settings'][key])
            for key in self.intSettings:
                self.intSettings[key].set(values['ButtonStates'][key])

    def loadROI(self):
        filename = tkFileDialog.askopenfilename(parent=root,initialdir=os.getcwd(),title = "Select an .xls or .ods file containing Regions of Interest.")
        if '.xls' in filename:
            wb = xlrd.open_workbook(filename)
            N = wb.nsheets
            for i in xrange(N):
                self.ROI.append([])
                s = wb.sheet_by_index(i)
                tmp = [0]*6 #
                for r in xrange(s.nrows-1): #skip the first row
                    v = s.row_values(r+1,start_colx=1)
                    if r%2 == 0: #even row
                        tmp[0] = v[0]
                        tmp[1] = v[1]
                        tmp[2] = v[4]
                        tmp[3] = v[2]
                        tmp[4] = v[3]
                    else:
                        tmp[5] = v[5] - tmp[2]
                    self.ROI[i].append(tmp)
        elif '.ods' in filename:
            pass
        else:
            print("{:s} does not have proper extension. Currently supporting only .xls or .ods filetypes.")
            

    def run_segmentation(self):
        if not self.directories:
            print "WARNING: no directories have been indicated; nothing has been done."
            return
        if not self.ROI:
            print "WARNING: no region of interest loaded; assuming only 1 cell in the image."
        # translate smoothing parameters to pyCellAnalyst dictionary syntax
        if self.intSettings['smoothingMethod'].get() == 1:
            smoothingParameters = {}
        elif self.intSettings['smoothingMethod'].get() == 2:
            smoothingParameters = {'radius': self.settings['medianRadius'].get()}
        elif self.intSettings['smoothingMethod'].get() == 3:
            smoothingParameters = {'sigma': self.settings['gaussianSigma'].get()}
        elif self.intSettings['smoothingMethod'].get() == 4:
            smoothingParameters = {'iterations': self.settings['curvatureIterations'].get(),
                                   'conductance': self.settings['curvatureConductance'].get()}
        elif self.intSettings['smoothingMethod'].get() == 5:
            smoothingParamaters = {'iterations': self.settings['gradientIterations'].get(),
                                   'conductance': self.settings['gradientConductance'].get(),
                                   'time step': self.settings['gradientTimeStep'].get()}
        elif self.intSettings['smoothingMethod'].get() == 6:
            smoothingParameters = {'domainSigma': self.settings['bilateralDomainSigma'].get(),
                                   'rangeSigma': self.settings['bilateralRangeSigma'].get(),
                                   'samples': self.settings['bilateralSamples'].get()}
        elif self.intSettings['smoothingMethod'].get() == 7:
            noiseModel = ['no model', 'poisson', 'gaussian', 'rician']
            smoothingParameters = {'radius': self.settings['patchRadius'].get(),
                                   'iterations': self.settings['patchIterations'].get(),
                                   'patches': self.settings['patchNumber'].get(),
                                   'noise model': noiseModel[self.settings['patchNoiseModel'].get()-1]}

        objects = ['Foreground','Background']
        for i,d in enumerate(self.directories):
            regions = self.ROI[i]
            vol = Volume(d,
                         pixel_dim=            [self.settings['xdim'].get(),self.settings['ydim'].get(),self.settings['zdim'].get()],
                         regions=              region,
                         segmentation=         'User',
                         handle_overlap=       self.intSettings['handleOverlap'].get(),
                         display=              self.intSettings['display'].get(),
                         stain=                objects[self.intSettings['stain'].get()],
                         stretch=              self.intSettings['contrastStretching'].get(),
                         enhance_edge =        self.intSettings['edgeEnhancement'].get(),
                         smoothing_method=     self.smoothingMethods[self.intSettings['smoothingMethod'].get()-1],
                         smoothing_parameters= smoothingParameters)
                        
            if self.intSettings['activeMethod'].get() == 1:
                vol.thresholdSegmentation(method=self.thresholdMethods[self.intSettings['thresholdMethod'].get()-1],ratio=self.settings['thresholdPercentage'].get(),adaptive=self.intSettings['thresholdAdaptive'].get())
            elif self.intSettings['activeMethod'].get() == 2:
                vol.geodesicSegmentation(upsampling=2,
                                         seed_method=self.thresholdMethods[self.intSettings['thresholdMethod'].get()-1],
                                         ratio=self.settings['thresholdPercentage'].get(),
                                         canny_variance=(1.5,1.5,1.5),
                                         propagation=self.settings['geodesicPropagation'].get(),
                                         curvature=self.settings['geodesicCurvature'].get(),
                                         advection=self.settings['geodesicAdvection'].get(),
                                         active_iterations=self.settings['geodesicIterations'].get())
            vol.writeLabels()
            vol.writeSurfaces()
            
    def open_smoothing_reference(self,*args):
        webbrowser.open_new(self.smoothingLink)

    def open_threshold_reference(self,*args):
        webbrowser.open_new(self.thresholdLink)

    def update(self,*args):
        """dummy function to use trace feature"""
        pass

root = Tk()
root.title("Welcome to the pyCellAnalyst segmentation GUI.")
app = Application(root)

root.mainloop()
