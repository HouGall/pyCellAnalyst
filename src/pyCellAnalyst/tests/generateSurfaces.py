import argparse
import os

import vtk
from vtk.util import numpy_support
import numpy as np

def generateSurfaces(a=2.0, b=1.0, c=1.0, n1=0.9, n2=0.9, uniform=False, output=None, number=1, onefile=True):
    """
    Description
    -----------
    A utility function for generating VTK 3D polydata of known deformation. The reference geometry is a superellipsoid. Deformed geometries are generated by either applying a random thin-plate spline transform (default) or a homogeneous (linear, positive-definite) transform. By default a single file is written to disk, summary.vtp, with all deformation cases stored as vectors at each vertex. However, multiple files can be written for the reference and each deformation case. If onefile is set to False. For command line usage, type python generateSurfaces.py -h.

    Parameters
    ----------
    a : float=2.0
       The x-radius of the superellipsoid.
    b : float=1.0
       The y-radius of the superellipsoid.
    c : float=1.0
       The z-radius of the superellipsoid.
    n1 : float 0.9
       Shape parameter in v; (0.0, 1.0] ranges from squared to ellipsoidal corners, > 1.0 concave surface with sharp edges.
    n2 : float 0.9
       Shape parameter in u; (0.0, 1.0] ranges from squared to ellipsoidal corners, > 1.0 concave surface with sharp edges.
    uniform : bool=False
       If True will apply a homogeneous transform rather than thin-plate spline.
    output : str
       The output directory to write file(s) to. If not provided the current working directory will be used.
    number : int=1
       Number of deformed geometries to generate.
    onefile : bool=True
       If False, will write a file for the reference geometry and every generated deformed geometry.
    """

    if output is None:
        root = os.getcwd()
    elif os.path.isabs(output):
        root = output
    else:
        root = os.path.join(os.getcwd(), output)

    if not os.path.exists(root):
        os.mkdir(root)

    superEllipsoid = vtk.vtkParametricSuperEllipsoid()
    superEllipsoid.SetXRadius(a)
    superEllipsoid.SetYRadius(b)
    superEllipsoid.SetZRadius(c)
    superEllipsoid.SetN1(n1)
    superEllipsoid.SetN2(n2)

    ratios = np.array([a, b, c])
    ratios = ratios / np.max(ratios)
    superEllipsoidSource = vtk.vtkParametricFunctionSource()
    superEllipsoidSource.SetParametricFunction(superEllipsoid)
    superEllipsoidSource.SetUResolution(np.ceil(100*ratios[0]).astype(int))
    superEllipsoidSource.SetVResolution(np.ceil(100*ratios[1]).astype(int))
    superEllipsoidSource.SetWResolution(np.ceil(100*ratios[2]).astype(int))

    superEllipsoidSource.Update()
    refpolydata = superEllipsoidSource.GetOutput()
    reference = numpy_support.vtk_to_numpy(refpolydata.GetPoints().GetData())

    if uniform:
        pass
    else:
        bounds = refpolydata.GetBounds()
        x, xstep = np.linspace(bounds[0], bounds[1], num=np.ceil(3 * ratios[0]).astype(int) + 1, retstep=True)
        y, ystep = np.linspace(bounds[2], bounds[3], num=np.ceil(3 * ratios[1]).astype(int) + 1, retstep=True)
        z, zstep = np.linspace(bounds[4], bounds[5], num=np.ceil(3 * ratios[2]).astype(int) + 1, retstep=True)
        sourcepoints = np.meshgrid(x, y, z)

    for i in range(number):
        if uniform:
            maxit = 10
            cnt = 0
            while True and cnt < maxit:
                cnt += 1
                F = np.zeros((3,3), dtype=float)
                F[[0,1,2],[0,1,2]] = np.random.normal(loc=1.0, scale=0.3, size=3)
                F[[0,0,1,1,2,2],[1,2,0,2,0,1]] = np.random.normal(loc=0.0, scale=0.3, size=6)
                if np.linalg.det(F) > 0:
                    break
                print('Random transformation was not positive definite. Trying again...')
            transform = vtk.vtkMatrixToLinearTransform()
            m = vtk.vtkMatrix4x4()
            for j in range(3):
                for k in range(3):
                    m.SetElement(j,k, F[j,k])
            transform.SetInput(m)
        else:
            x_perturb = np.random.normal(loc=0.0, scale=0.15 * xstep, size=sourcepoints[0].size)
            y_perturb = np.random.normal(loc=0.0, scale=0.15 * ystep, size=sourcepoints[1].size)
            z_perturb = np.random.normal(loc=0.0, scale=0.15 * zstep, size=sourcepoints[2].size)

            allsourcepoints = np.zeros(sourcepoints[0].size * 3)
            allsourcepoints[0::3] = sourcepoints[0].ravel()
            allsourcepoints[1::3] = sourcepoints[1].ravel()
            allsourcepoints[2::3] = sourcepoints[2].ravel()

            alltargetpoints = np.copy(allsourcepoints)
            alltargetpoints[0::3] += x_perturb
            alltargetpoints[1::3] += y_perturb
            alltargetpoints[2::3] += z_perturb

            sourcePoints = vtk.vtkPoints()
            targetPoints = vtk.vtkPoints()
            arr1 = numpy_support.numpy_to_vtk(allsourcepoints, deep=True, array_type=vtk.VTK_DOUBLE)
            arr1.SetNumberOfComponents(3)
            arr2 = numpy_support.numpy_to_vtk(alltargetpoints, deep=True, array_type=vtk.VTK_DOUBLE)
            arr2.SetNumberOfComponents(3)
            sourcePoints.SetData(arr1)
            targetPoints.SetData(arr2)

            transform = vtk.vtkThinPlateSplineTransform()
            transform.SetSourceLandmarks(sourcePoints)
            transform.SetTargetLandmarks(targetPoints)
            transform.SetBasisToR()

        polytransform = vtk.vtkTransformPolyDataFilter()
        polytransform.SetInputConnection(superEllipsoidSource.GetOutputPort())
        polytransform.SetTransform(transform)
        polytransform.Update()

        polydata = polytransform.GetOutput()

        deformed = numpy_support.vtk_to_numpy(polydata.GetPoints().GetData())
        displacements = numpy_support.numpy_to_vtk((deformed - reference).ravel(), deep=True, array_type=vtk.VTK_DOUBLE)
        displacements.SetName('Displacement_{:03d}'.format(i+1))
        displacements.SetNumberOfComponents(3)

        refpolydata.GetPointData().AddArray(displacements)

    writer = vtk.vtkXMLPolyDataWriter()
    if onefile:
        writer.SetFileName(os.path.join(root, 'summary.vtp'))
        writer.SetInputData(refpolydata)
        writer.Write()
    else:
        tmppolydata = vtk.vtkPolyData()
        tmppolydata.CopyStructure(refpolydata)
        normals = vtk.vtkPolyDataNormals()
        normals.ComputePointNormalsOn()
        normals.SetInputData(tmppolydata)
        writer.SetFileName(os.path.join(root, 'reference.vtp'))
        writer.SetInputConnection(normals.GetOutputPort())
        writer.Write()
        for i in range(number):
            tmppolydata = vtk.vtkPolyData()
            tmppolydata.CopyStructure(refpolydata)
            arr = refpolydata.GetPointData().GetArray('Displacement_{:03d}'.format(i+1))
            arr.SetName('Displacement')
            tmppolydata.GetPointData().AddArray(arr)
            tmppolydata.GetPointData().SetActiveVectors('Displacement')
            warp = vtk.vtkWarpVector()
            warp.SetInputData(tmppolydata)
            warp.SetScaleFactor(1.0)
            warp.Update()
            normals.SetInputConnection(warp.GetOutputPort())
            writer.SetFileName(os.path.join(root, 'deformed_{:03d}.vtp'.format(i+1)))
            writer.SetInputConnection(normals.GetOutputPort())
            writer.Write()




if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Generates reference and deformed VTK 3D polydata. The reference geometry is defined by a super-ellipsoid function.')
    parser.add_argument('-a', type=float, default=2.0, help='float : x-radius of reference super-ellipsoid')
    parser.add_argument('-b', type=float, default=1.0, help='float : y-radius of reference super-ellipsoid')
    parser.add_argument('-c', type=float, default=1.0, help='float : z-radius of reference super-ellipsoid')
    parser.add_argument('-n1', type=float, default=0.9,
                        help='float : shape parameter in v; (0.0,1.0) square to rounded corners 1.0 is ellipsoid, > 1.0 concave with sharp edges')
    parser.add_argument('-n2', type=float, default=0.9,
                        help='float : shape parameter in u; (0.0,1.0) square to rounded corners 1.0 is ellipsoid, > 1.0 concave with sharp edges')
    parser.add_argument('-uniform', dest='uniform', action='store_true',
                        help='Apply positive-definite uniform (linear i.e. no rigid translation) deformations.')
    parser.add_argument('-output', type=str, default=None, help='str : output directory to write surfaces to')
    parser.add_argument('-number', type=int, default=1, help='int : how many deformed surfaces to generate')
    parser.add_argument('-multiple', dest='onefile', action='store_false',
                        help='An individual polydata will be written for the reference and each deformation case.')
    args = parser.parse_args()
    print(args)
    generateSurfaces(a=args.a, b=args.b, c=args.c, n1=args.n1, n2=args.n2, uniform=args.uniform,
                     output=args.output, number=args.number, onefile=args.onefile)

